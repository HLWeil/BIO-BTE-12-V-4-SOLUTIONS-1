[{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/index.html","title":"BIO-BTE-12-V-4-Solutions\n","content":"# BIO-BTE-12-V-4-Solutions\n\n\u003Cbr\u003E\n\nDeutscher titel: **Wissenschaftliche Programmierung f\u00FCr Biolog*innen (Vorlesung/\u00DCbung) - Musterl\u00F6sungen**\n\nEnglish title: **Scientific Programming For Biologists (Lecture \u0026 Exercise) - Solutions**\n\nKIS: [BIO-BTE-12-V-4](https://www.kis.uni-kl.de/campus/all/event.asp?gguid=0xD702B068C88449BEAF7C4E9C1EEE592D\u0026tguid=0xA0CC12CC38514E09833533E643742D94)\n\n**Credit Points (CP): 3**"},{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/task-solutions/german/wpb-task-04-solution.html","title":"04 Programming with functions","content":"(**\n---\ntitle: 04 Programming with functions\ncategory: Musterl\u00F6sungen(deutsch)\ncategoryindex: 1\nindex: 4\n---\n*)\n\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/BIO-BTE-12-V-4/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n\n# Task04 - Programming with functions\n\n## Funktionen h\u00F6herer Ordnung\n\n### Task 1.1:\n\nSchreibe folgende Funktion mit Hilfe des Pipe-Operators \u0060|\u003E\u0060 und den angegebenen Funktionen.\n\nTipp: \n\n  - Der Pipeoperator setzt den Parameter links vom Operator ans Ende der rechten Seite: \n\n  - \u0060a |\u003E add b\u0060 ist gleichbedeutend mit \u0060add b a\u0060\n\n*)\nlet mathNotation x y = ((2. \u002B 3. * (x \u002B 1.))**2.) * y\n\n\nlet add (a:float) b = a \u002B b\nlet square (x :float) = x * x\nlet multiply (a:float) b = a * b\n\n\nlet pipeNotation x y =\n    x\n    |\u003E add 1.\n    |\u003E multiply 3.\n    |\u003E add 2.\n    |\u003E square\n    |\u003E multiply y\n\n// Test ob beide notationen das gleiche Ergebnis erzeugen\npipeNotation 1. 7. = mathNotation 1. 7.\n\n(**\n### Task 1.2\n\nDeklariere eine beliebige Funktion mit der Signatur \u0060int -\u003E int -\u003E int\u0060. Achte darauf, dass alle Parameter im Funktionsk\u00F6rper verwendet werden.\n\nIst dies eine Funktion erster Ordnung oder eine Funktion h\u00F6herer Ordnung?\n\n\n*)\n\nlet subtract a b = a - b\n//  Funktion 1. Ordnung \n\n(**\n### Task 1.3\n\nDeklariere eine beliebige Funktion mit der Signatur \u0060int -\u003E int -\u003E (int -\u003E int -\u003E int) -\u003E float\u0060. Achte darauf, dass alle Parameter verwendet werden.\n\nIst dies eine Funktion erster Ordnung oder eine Funktion h\u00F6herer Ordnung?\n*)\n\nlet testFunction a b (f:int -\u003E int -\u003E int) =\n    f a b\n    |\u003E float\n\n// Funktion h\u00F6herer Ordnung\n\n\n(** \n### Task 1.4\n\nRufe die in \u00601.3\u0060 erstellte Funktion auf. Nutze als Parameter zwei beliebige Werte sowie die Funktion aus \u00601.2\u0060.\n\n*)\n\ntestFunction 2 4 subtract\n\n(**\n## Programmieren mit Funktionen\n\n### Task 2.1.1\n\nUnten siehst du einen record type mit dem Namen \u0060Cat\u0060. \nErstelle zwei beliebige Werte des Typs \u0060Cat\u0060 und binde sie an beliebige Namen.\nSchaut euch \u0060\u00DCbung 02\u0060 an, falls es hier Schwierigkeiten geben sollte.\n\n\n*)\ntype Cat = {\n    Name    : string\n    Weight  : float\n    Color   : string\n    Age     : int}\n\nlet createCat n w c a = {Name=n;Weight=w;Color=c;Age=a}\n\nlet paul = createCat \u0022Paulchen\u0022 4.2 \u0022black\u0022 6\nlet lisa = createCat \u0022Lischen\u0022 3.3 \u0022red\u0022 2\n\n(**\n### Task 2.1.2\n\nDeklariere eine Funktion mit dem Namen \u0060getWeight\u0060, die als Parameter eine \u0060Cat\u0060 erh\u00E4lt und deren Gewicht zur\u00FCck gibt. \n\n*)\n\nlet getWeight cat = cat.Weight\n\n(**\n### Task 2.1.3\n\nDu kannst keine mathematischen Standard-Operatoren auf record typen anwenden. \nDeklariere eine Funktion mit dem Namen \u0060applyToWeight\u0060, die zwei Parameter vom Typ \u0060Cat\u0060 (c1 und c2) und einen Parameter vom Typ \u0060(float -\u003E float -\u003E float)\u0060 (f) erh\u00E4lt. \nIm Funktionsk\u00F6rper soll die Funktion f auf die Gewichte der beiden Katzen c1 und c2 angewendet werden.\n\nTipp: Definiere die Typen der Parameter. \n\n\n*)\n\nlet applyToWeight (c1:Cat) c2 (f:float -\u003E float -\u003E float) =\n    f c1.Weight c2.Weight\n\n(**\n### Task 2.1.4\n\nWende die Funktion \u0060applyToWeight\u0060 mit den zuvor erstellten \u0060Cats\u0060 und der Funktion \u0060averageOfTwo\u0060 an.  \n\n\n*)\nlet averageOfTwo (a:float) b =\n    (a \u002B b) / 2.\n\napplyToWeight paul lisa averageOfTwo\n\n(**\n### Task 2.2 (optional)\n\nDiese Aufgabe muss nicht gel\u00F6st werden! Sie dient dazu eine \u0060Cat list\u0060 zu erstellen, die an sp\u00E4terer Stelle ben\u00F6tigt wird.\nWenn du willst, kannst du kommentieren was in den angegebenen Zeilen geschieht (Extrapunkt)\n\n\n*)\n// Dies ist ein Zufallsgenerator. \n// Mit randomNumberGenerator.NextDouble() kann nun ein zuf\u00E4lliger float zwischen 0. und 1. erstellt werden.\n// Mit randomNumberGenerator.Next(x) kann nun ein zuf\u00E4lliger int zwischen 0 und x-1 erstellt werden.\nlet randomNumberGenerator = System.Random()\n\n// Nachfolgend ist eine Funktion dargestellt, die einen Wert vom Typ Cat erstellt.\nlet createRandomCat (i :int) = \n    // Kommentar: An \u0027name\u0027 wird ein string gebunden, der aus dem Zusammenschluss aus \u0022Cat \u0022 und dem Parameter i (integer) besteht, der zu einem string umgewandelt wird.\n    let name   = \u0022Cat \u0022 \u002B string i \n    // Kommentar: An \u0027age\u0027 wird ein integer gebunden, der eine zufaellige Zahl zwischen 0 und 15 ist.\n    let age    = randomNumberGenerator.Next(16)\n    // Kommentar: An \u0027weight\u0027 wird ein float gebunden, der aus einer Berechnung (3\u002B5x) mit einem zufaelligen Wert zwischen 0. und 1. ensteht.\n    let weight = 3. \u002B 5. * randomNumberGenerator.NextDouble()\n    let color  = \n        let colors = [\u0022white\u0022;\u0022red\u0022;\u0022black\u0022;\u0022grey\u0022;\u0022mixed\u0022]\n        // Kommentar: Das \u0027colors\u0027 Array ist 5 Elemente lang. Der Index der zu waehlenden Farbe wird durch modulo 5 bestimmt.\n        // Wenn i \u003E 4, dann liegt der Teilungs-Rest zwischen 0 und 4. Damit ist fuer jeden integer eine Farbe definiert.\n        colors.[i%5]\n    // Kommentar: Hier wird ein Wert des Typs Cat mithilfe der zuvor erstellten Wertebindung erstellt (instantiiert).\n    {\n    Name    = name\n    Weight  = weight\n    Color   = color   \n    Age     = age\n    }\n\n// Kommentar: Hier wird eine Cat-Liste erstellt, die 60 random cats enthaelt\nlet catList = [for i=1 to 60 do yield createRandomCat i]\n(**\n### Task 2.3\n\nErstelle eine float List mit den Werten von 0. bis 100. und binde sie an den Namen \u0060nList\u0060.\n\n\n*)\n\nlet nList = [1. .. 100.]\n\n(**\n### Task 2.4\n\nMit map-Funktionen kann man eine Funktion, die auf einzelnen Elementen angewendet werden kann auf alle Elemente einer Liste anwenden.\nParameter der \u0060map\u0060-Funktion:\n\n  1. \u0060doSomethingWithX\u0060:  Funktion, die auf jedes Listenelement angewendet werden soll\n\n  2. \u0060list\u0060:              Liste der Elemente, auf die \u0060doSomeThingWithX\u0060 angewendet werden soll\n\nDie \u0060List.map\u0060 Funktion wird dann folgenderma\u00DFen angewendet:\n\n  - \u0060List.map (fun listElement -\u003E doSomethingWithX listElement) list\u0060\n\nWende auf jedes Element von \u0060nList\u0060 die Funktion \u0060square\u0060 (Task 1.1) an. Binde das Ergebnis an den Namen \u0060nListSquared\u0060.\n\n*)\n\nlet nListSquared = List.map (fun x -\u003E square x) nList\n\n(**\n### Task 2.5\n\nExtrahiere alle Gewichte aus \u0027catList\u0027 und binde sie an den Namen \u0060catWeights\u0060.\n\n\n*)\n\nlet catWeights = catList |\u003E List.map (fun x -\u003E x.Weight)\n\n(**\n### Task 2.6\n\nBerechne die Summe der Werte aus \u0060nList\u0060. \n\nTipp: Durchsuche das \u0060List\u0060-Modul nach einer passenden Funktion.\n\n*)\n\nList.sum nList\n\n(**\n### Task 2.7\n\nFiltere alle Listenelemente, die durch 15 teilbar sind.\n\nTipp1: Nutze \u0060List.filter\u0060 und die angegebene Funktion.\n*)\n\nlet isDivisibleWithoutRemainder denumerator numerator = \n     numerator % denumerator = 0.\n\nList.filter (isDivisibleWithoutRemainder 15.) nList\n\n(**\n### Task 2.8\n\nBerechne die Summe der Quadrate der einzelnen Werte aus nList.\nVersuche dieses in einem Schritt mit \u0060List.fold\u0060 zu erreichen.\n*)\n\nList.fold (fun acc x -\u003E acc \u002B square x) 0. nList\n\n(**\n### Task 2.9\n\nBerechne das Durchschnittsgewicht der Katzen aus \u0060catList\u0060. \n\nTipp: Die Aufgabe kann entweder durch die Nutzung von Funktionen aus dem \u0060List\u0060-Modul gel\u00F6st werden, oder man l\u00F6st sie durch eine einzige fold Funktion (f\u00FCr Experten).\n*)\n\nList.average catWeights\n\nList.fold (fun acc x -\u003E acc \u002B (x / float catWeights.Length)) 0. catWeights"},{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/task-solutions/german/wpb-task-05-solution.html","title":"05 Programming with Objects","content":"(**\n---\ntitle: 05 Programming with Objects \ncategory: Musterl\u00F6sungen(deutsch)\ncategoryindex: 1\nindex: 5\n---\n*)\n\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/BIO-BTE-12-V-4/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# Task05 - Programming with Objects \n\n## Ver\u00E4nderliche Werte\n\n### Task 1.1:\n\nErstellen und Ver\u00E4ndern von ver\u00E4nderlichen Werten\n\nTipp: \n\n- Benutzt das \u0060mutable\u0060 keyword\n- Zur Ver\u00E4nderung der Werte wird der \u0060\u003C-\u0060 Operator verwendet\n\n### Subtask 1.1.1\n\nErstelle einen ver\u00E4nderlichen Integer mit dem Wert 1 und bindet ihn an den Namen x\n\n\n*)\n\nlet mutable x = 1\n\n(**\n### Subtask 1.1.2\n\nVer\u00E4ndere den Wert der an x gebunden ist indem ihr den Wert den x tr\u00E4gt mit 5 multipliziert \n\n*)\n\nx \u003C- (x * 5)\n\n(**\n### Subtask 1.1.3\n\nErstelle einen Record Type \u0060Mensch\u0060 mit \n\n- dem unver\u00E4nderlichen Feld \u0060Name\u0060 vom Typ string\n- und dem ver\u00E4nderlichen Feld \u0060Alter\u0060 vom Typ int\n\n*)\n\ntype Mensch =\n    {\n        Name : string\n        mutable Alter : int\n    }\n\n(**\n### Subtask 1.1.4\n\nErstelle die Funktion \u0060geburtstagFeiern\u0060 die als Parameter einen Wert des Typen \u0060Mensch\u0060 erh\u00E4lt und das Alter des Menschen um eins erh\u00F6ht\n\n*)\n\nlet geburtstagFeiern (m : Mensch) =\n    m.Alter \u003C- m.Alter \u002B 1\n\n(**\n### Subtask 1.1.5\n\nErstelle einen Menschen, binde ihn an einen Namen und lass diesen erstellten Menschen mit der Funktion \u0060geburtstagFeiern\u0060 altern.\n\n*)\n\nlet mensch1 = { Name = \u0022Max\u0022; Alter = 22 }\n\ngeburtstagFeiern mensch1\n\n(**\n### Task 1.2 (Bonusaufgabe) Ver\u00E4nderliche Werte in Funktionen\n\nErstelle eine eigene Version der \u0060Array.max\u0060 Funktion. Diese Funktion soll ein Array von ints erhalten und den gr\u00F6\u00DFten der ints zur\u00FCckgeben.\nSignatur: \u0060int [] -\u003E int\u0060\n\nDabei soll der aktuell gr\u00F6\u00DFte int ein \u0060ver\u00E4nderlicher Wert\u0060 sein und es soll eine \u0060for-Schleife\u0060 verwendet werden.\n\n*)\n\nlet arrayMax (array : int[]) = \n    let mutable maxValue = array.[0] \n    for i in array do\n        if i \u003E maxValue then\n            maxValue \u003C- i\n    maxValue\n\nlet arrayMax2 (array : int[]) = \n    let mutable maxValue = array.[0] \n    for i = 1 to array.Length - 1 do\n        if array.[i] \u003E maxValue then\n            maxValue \u003C- array.[i]\n    maxValue\n\nlet array1 = [|4; 23; 6; 4; 7|]\n\narrayMax array1\narrayMax2 array1\n\n(**\n## Vererbung\n\n### Task 2.1 Erstellen von Klassen und Objekten\n\n### Subtask 2.1.1\n\nIm folgenden wird die Klasse \u0060Fahrzeug\u0060 erstellt. Versuche nachzuvollziehen, was passiert und kommentiere jede Zeile kurz\n\nKeywortfundgrube: Methode, Feld, Konstruktor, Parameter, alternativ, binden\n\n\n*)\n\n// Kommentar: Es wird eine Klasse namens \u0060Fahrzeug\u0060 erstellt, deren Hauptkonstruktor einen Parameter namens \u0060hersteller\u0060 vom Typ string erh\u00E4lt\ntype Fahrzeug (hersteller:string) =\n    // Kommentar: Ein Feld namens \u0060Hersteller\u0060 wird definiert, an das der Wert des parameters \u0060hersteller\u0060 gebunden wird\n    member self.Hersteller = hersteller\n    // Kommentar: Es wird eine parameterlose Methode namens \u0060Fahren\u0060 definiert, welche \u00FCber die Selbstreferenz das Feld \u0060Hersteller\u0060 verwendet\n    member self.Fahren() = printfn \u0022%s macht brumm brumm\u0022 self.Hersteller\n    // Kommentar: Ein parameterloser alternativer Konstruktor wird erstellt.\n    new() = Fahrzeug(\u0022VW\u0022)\n\n(**\n### Subtask 2.1.2\n\nInstanziiere 2 Objekte des Typs \u0060Fahrzeug\u0060. Verwende einmal den den Haupt- und einmal den alternativen Konstruktor\n\n*)\n\nlet car1 = new Fahrzeug(\u0022Ford\u0022)\n\nlet car2 = new Fahrzeug()\n\n(**\n### Task 2.2 Vererbung\n\n### Subtask 2.2.1\n\nHier ist ein Beispiel f\u00FCr die Vererbung eines Typen, namentlich der Typ \u0060Motorrad\u0060 der vom Typ \u0060Fahrzeug\u0060 erbt. \n\nErstelle analog einen Typen \u0060Auto\u0060, der auch vom Typ \u0060Fahrzeug\u0060 erben soll. Dieser Typ soll aber zus\u00E4tzlich das Feld \u0060AnzahlTueren\u0060 enthalten. \nW\u00E4hle hierzu einen passenden primitiven Typen und passe auch den Konstruktor an, sodass diese Anzahl der T\u00FCren auch beim Instanziieren gesetzt werden kann.\n\n*)\n\ntype Motorrad (hersteller:string) =\n\n    inherit Fahrzeug(hersteller)\n\n    new() = Motorrad(\u0022Kawasaki\u0022)\n\ntype Auto (hersteller : string, anzahlTueren : int) =\n\n    inherit Fahrzeug(hersteller)\n\n    member self.AnzahlTueren = anzahlTueren\n\n    new() = Auto(\u0022Mercedes\u0022,4)\n\n(**\n### Subtask 2.2.2\n\nErstelle eine Funktion, welche einen Parameter des Typs \u0060Fahrzeug\u0060 enth\u00E4lt und die Methode \u0060Fahren\u0060 dieses Fahrzeuges ausf\u00FChrt.\n\n*)\n\nlet fahren (fahrzeug : #Fahrzeug) =\n\n    fahrzeug.Fahren()\n\n(**\n### Subtask 2.2.3\n\nErstelle ein \u0060Auto\u0060 und binde en an einen Namen. Dann wende die oben definierte Funktion zum \u0060Fahren\u0060 darauf an.\n\n*)\n\nlet car3 = new Auto(\u0022Toyota\u0022, 3)\n\nfahren car3\n\n(**\n\n### Task 2.3 (Bonusaufgabe) Ver\u00E4nderliche Werte in Objekten\n\nDeklariere eine Klasse \u0060Cabrio\u0060 die vom Typ \u0060Fahrzeug\u0060 erbt. \n\nDiese Klasse soll ein Feld \u0060DachOffen\u0060 vom Typ \u0060bool\u0060 haben und zus\u00E4tzlich Methoden, mit denen man das Dach \u00F6ffnen und schlie\u00DFen kann\n\n*)\n\n// L\u00F6sung \u00FCber Feld nur mit get (default), und Methoden die das Verhalten regeln (bevorzugt)\ntype Cabrio (hersteller:string, tueren:int) =\n\n    inherit Auto(hersteller,tueren)\n\n    let mutable dachOffen = false\n\n    // Feld abrufbar aber nicht verw\u00E4nderbar\n    member this.DachOffen = dachOffen\n\n    // Methoden, zur gezielten Zustands\u00E4nderung\n    member self.Oeffnen() = \n        if dachOffen then printfn \u0022Das Dach ist bereits offen!\u0022\n        else printfn \u0022Das Dach ist jetzt offen.\u0022\n        dachOffen \u003C- true\n\n    member self.Schliessen() = \n        if dachOffen then printfn \u0022Das Dach ist jetzt zu!\u0022\n        else printfn \u0022Das Dach ist schon zu!\u0022\n        dachOffen \u003C- false        \n\n    // Methoden, zum automatischen Zustandswechsel\n    member this.DachBetaetigen() =\n        if dachOffen = true then \n            dachOffen \u003C- false\n        else\n            dachOffen \u003C- true\n\n// Zus\u00E4tzliche Hilfsfunktionen\nlet dachSchliessen (c:Cabrio) = \n    c.Schliessen()\n\nlet dachOeffnen (c:Cabrio) = \n    c.Oeffnen()\n\n\nlet neuesCabrio = new Cabrio(\u0022Audi\u0022,4)\n\ndachOeffnen neuesCabrio\n\n\n\n// L\u00F6sung \u00FCber Feld mit get/set, ohne Methoden\ntype Cabrio2 (hersteller:string, tueren:int) =\n\n    inherit Auto(hersteller,tueren)\n\n    let mutable dachOffen = false\n\n    // Feld abrufbar und verw\u00E4nderbar\n    member this.DachOffen\n        with get () = dachOffen\n        and set (v) = dachOffen \u003C- v\n\n// In diesem Fall m\u00FCssten die Funktionen die Logik selbst tragen\nlet dachOeffnen2 (c:Cabrio2) = \n    if c.DachOffen then printfn \u0022Das Dach ist bereits offen!\u0022\n    else printfn \u0022Das Dach ist jetzt offen.\u0022\n    c.DachOffen \u003C- true\n\nlet dachSchliessen2 (c:Cabrio2) = \n    if c.DachOffen then printfn \u0022Das Dach ist jetzt zu!\u0022\n    else printfn \u0022Das Dach ist schon zu!\u0022\n    c.DachOffen \u003C- false       \n\nlet neuesCabrio2 = new Cabrio2(\u0022Audi\u0022,4)\n\ndachOeffnen2 neuesCabrio2 \n\n\n(**\n## Polymorphismus\n\n### Task 3.1\n\nWir wollen hier Personen implementieren, die ihren Namen sagen k\u00F6nnen. In Japan wird auch im allt\u00E4glichen Leben normalerweise der Familienname vor dem Eigennamen genannt. \nSo ist Yoko Ono in Japan als Ono Yoko bekannt. Um diesen Unterschied programmatisch darzustellen, wurde der Code folgendermassen geschrieben:\n\nOrdne die folgenden Begriffen den zugeh\u00F6rigen Codebausteinen zu: \u0060Klassendeklaration\u0060, \u0060Objektinstanziierung\u0060, \u0060Interfacedeklaration\u0060\n\n\n*)\n// Bezeichnung: Interfacedeklaration\ntype IPerson =\n    abstract FamilienName   : string\n    abstract EigenName      : string\n    abstract NamenSagen     : unit -\u003E string\n\n// Bezeichnung: Klassendeklaration\ntype Japaner (fn, en) =\n    let familienName = fn\n    let eigenName = en\n    interface IPerson with\n        member self.FamilienName = familienName\n        member self.EigenName = eigenName\n        member self.NamenSagen () = familienName \u002B \u0022 \u0022 \u002B eigenName\n\n// Bezeichnung: Klassendeklaration\ntype Deutscher (fn, en) =\n    let familienName = fn\n    let eigenName = en\n    interface IPerson with\n        member self.FamilienName = familienName\n        member self.EigenName = eigenName\n        member self.NamenSagen () = eigenName \u002B \u0022 \u0022 \u002B familienName\n\n// Bezeichnung: Objektinstanziierung\nlet yokoOno = Japaner(\u0022Ono\u0022,\u0022Yoko\u0022)\n\n// Bezeichnung: Objektinstanziierung\nlet angeloMerte = Deutscher(\u0022Merte\u0022,\u0022Angelo\u0022)\n(**\n### Task 3.2\n\nGreife auf die Methode \u0060NamenSagen\u0060 der beiden Personen zu. \nTipp: Verwende den korrekten \u0060casting Operator\u0060\n\n*)\n// Variante1\nlet say = yokoOno :\u003E IPerson\nsay.NamenSagen()\n\n// Variante2\n(angeloMerte :\u003E IPerson).NamenSagen()\n\n// Variante3\nlet namenSagen (p : #IPerson) =\n    p.NamenSagen()\n\nnamenSagen yokoOno\n\n(**\n### Task 3.3\n\nErkl\u00E4re kurz in eigenen Worten, warum in diesem Beispiel Polymorphismus verwendet wurde und nicht Vererbung.\n\n*)\n\n// In diesem Fall sollen alle Personen die gleiche Methode \u0060NamenSagen\u0060 besitzen. Was genau in der Methode passiert soll aber je nach Nationalit\u00E4t unterschiedlich sein.\n// Bei Vererbung w\u00FCrde das Verhalten der Methode einmal definiert werden und alle erbenden Personen w\u00FCrde den Namen auf die gleich Weise sagen.\n// Polymorphismus erlaubt es, dass das konkrete Verhalten sich f\u00FCr die gleich benutzbare Methode zwischen den Leuten unterscheidet.\n\n(**\n### Task 3.4\n\nIm fernen Land Dingeldongel wird wie auch in Deutschland erst der Eigenname und dann der Familienname genannt. Beide werden jedoch revertiert. (Angela Merkel -\u003E alegnA lekreM)\n\nDeklariere die Klasse \u0060Dingeldongler\u0060, die das Interface \u0060IPerson\u0060 implementiert.\n\nTipp: Verwende die gegebene string-revertier Funktion\n\n\n*)\nlet revert (s:string) = System.String(s.ToCharArray() |\u003E Array.rev)\n\ntype Dingeldongler (fn, en) =\n    let familienName = fn\n    let eigenName = en \n    interface IPerson with\n        member self.FamilienName = familienName\n        member self.EigenName = eigenName\n        member self.NamenSagen () = revert eigenName \u002B \u0022 \u0022 \u002B revert familienName\n\nlet amblimKamblim = Dingeldongler(\u0022Kamblim\u0022, \u0022Amblim\u0022)\n(amblimKamblim :\u003E IPerson).NamenSagen()"}]