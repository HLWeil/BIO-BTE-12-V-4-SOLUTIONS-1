[{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/index.html","title":"BIO-BTE-12-V-4-Solutions\n","content":"# BIO-BTE-12-V-4-Solutions\n\n\u003Cbr\u003E\n\nDeutscher titel: **Wissenschaftliche Programmierung f\u00FCr Biolog*innen (Vorlesung/\u00DCbung) - Musterl\u00F6sungen**\n\nEnglish title: **Scientific Programming For Biologists (Lecture \u0026 Exercise) - Solutions**\n\nKIS: [BIO-BTE-12-V-4](https://www.kis.uni-kl.de/campus/all/event.asp?gguid=0xD702B068C88449BEAF7C4E9C1EEE592D\u0026tguid=0xA0CC12CC38514E09833533E643742D94)\n\n**Credit Points (CP): 3**"},{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/task-solutions/english/wpb-task-01-solution.html","title":"01 Hello F#","content":"(**\n---\ntitle: 01 Hello F#\ncategory: Model solution(english)\ncategoryindex: 2\nindex: 1\n---\n*)\n\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/BIO-BTE-12-V-4/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n# Task01 - Hello F#\n\n\n-------------------------------\nLet\u0027s start with the basics:\n- **In a .fsx script:** \n    Highlight the \u002710\u0027 and press Alt\u002BEnter, which will open a console and give the output \u0027val it: int = 10\u0027.\n    (If the code to execute has only one line, you can just click into the line and press Alt\u002BEnter without highlighting.)\n- **In a notebook:**\n    There is a \u0027play\u0027 button in the left upper corner of the field below. Press it to execute the respective code block, \n    which in this case will simply give \u002710\u0027 as output. \n    **Note that you always have to end codeblocks in notebooks with the value you want to put out**\n*)\n\n10\n\n(**\nWorking in this interactive way has the advantage that you can always directly test your code and look at the output.\nTry it with the line below and appreciate that the result of the calculation is 30.\n*)\n\n10 \u002B 20\n\n(**\nEverything after a \u0060//\u0060 or inside of \u0060(* ... *)\u0060 is treated as a comment and will not get executed as code.\nYou can use \u0060(* ... *)\u0060 to comment parts of a single line. \nThe standard keybinding for commenting a selection is (Strg \u002B K -\u003E Strg \u002B C)\n*)\n\n10 (*\u002B 40 *) \u002B 30\n\n(**\nIf you not quite get a task right, please submit partial solutions or trails of thought as comments to get partial points!\n## Das \u0027let\u0027-Binding\n## Task 1\n### Task 1.1\nBind the value 10 to the name \u0027x\u0027. Bind the value 20 to the name \u0027kaesebrot\u0027.\n*)\n\nlet x = 10\n\nlet kaesebrot = 20\n\n(**\n### Task 1.2\nBind the result of the Addition of \u0027x\u0027 and 10 to the name \u0027y\u0027.\n*)\n\nlet y = x \u002B 10\n\n(**\n### Task 1.3\nBind any first name as string to \u0027vorname\u0027.\n*)\n\nlet vorname = \u0022Vorname\u0022\n\n(**\n### Task 1.4\nCalculate the remainder of 432858049/41 and bind the result to \u0027modulo\u0027\n*)\n\nlet modulo = 432858049%41\n\n(**\n### Task 1.5\nBinde the sum of both sums (x \u002B 10) and (y \u002B 20) to the Name \u0027sumXY\u0027. \nDie Zwischenergebnisse sollten nicht im globalen Sichtbarkeitsbereich (Scope) liegen.\n*)\n\nlet summeXY =\n    let summeX = x \u002B 10\n    let summeY = y \u002B 20\n    summeX \u002B summeY\n\n// shorter version without intermediate results:\nlet summeXY\u0027 = x \u002B 10 \u002B y \u002B 20\n\n(**\n## Die \u0022printfn\u0022 - Funktion\n### Task 2\n_Tipp: https://docs.microsoft.com/de-de/dotnet/fsharp/language-reference/plaintext-formatting_\n### Task 2.1:  \nUse the printfn function to print \u0022Hello F#\u0022 to the console.\n*)\n\nprintfn \u0022Hallo F#\u0022\n\n(**\n### Task 2.2:  \nUse the printfn function to print the value of \u0027vorname\u0027 to the console.\n*)\n\nprintfn \u0022%s\u0022 vorname\n\n(**\n### Task 2.3:  \nUse the printfn function to print the value of \u0027y\u0027 to the console.\n*)\n\nprintfn \u0022%i\u0022 y\n\n(**\n## Primitive Datentypen und Funktionen\n### Task 3\n### Task 3.1\nBind an arbitrary integer value to the name intI.\n*)\n\nlet intI = 1\n\n(**\n### Task 3.2\nBind an arbitrary float value to the name floatI.\n*)\n\nlet floatI = 2.\n\n(**\n### Task 3.3\nConvert one of intI or floatI to the data type of the other and sum both up.\n*)\n\nintI \u002B int floatI\n\n// or:\nfloat intI \u002B floatI\n\n(**\n### Task 3.4\nCalculate the integer division of \u002727\u0027 und \u002713\u0027. Then perform the same operation but on \u002727\u0027 and \u002713\u0027 as float values.\n*)\n\n27 / 13\n\nfloat 27 / float 13\n\n(**\n### Task 3.5:\nConcatenate an arbitrary string value with an arbitrary char (character)\n*)\n\n\u0022myStrin\u0022 \u002B string \u0027g\u0027\n\n(**\n### Task 3.6:\nDeclare a function named \u0027mulitplyBy2\u0027 that doubles a single input float.\n*)\n\nlet multiplyBy2 (x:float) = 2.0 * x\n\n(**\n### Task 3.7:  \nDeclare a function named \u0027calculateCylinderVolume\u0027 that takes radius and length of a cylinder as inputs and \nreturns the cylinders volume AND additionally prints the message \u0022The volume of the cylinder is XXX\u0022 (where XXX is the volume)\nWhy can it make sense to print values inside a function before returning a value?\n*)\n\n// Possible answer: The printf function allows visualization of intermediate results.\nlet calculateCylinderVolume radius length =\n    let volume = System.Math.PI * radius * radius * length\n    printfn \u0022The volume of the cylinder is: %f\u0022 volume\n    // The returned value is the same as the value bound to \u0022volume\u0022\n    volume\n\n(**\n### Task 3.8:  \nDeclare a function that takes an integer as input, converts it, and applies the previously defined \u0027multiplyBy2\u0027 function on it.\n*)\n\nlet multiplyBy2Two x = multiplyBy2 (float x)\n\n(**\n### Task 3.9:  \nDeclare a function that takes the feollowing inputs:\n- two floats\n- a comparison operator (\u003C, \u003E, = )\n- a boolean\nThe function should then compare the result of applying the operator to the two \nfloat inputs with the boolean input and return the result.\n(_2 Points_)\n*)\n\nlet compare (x:float) (y:float) (op: float  -\u003E float -\u003E bool) (boolWert:bool) = \n    let tmp = op x y \n    tmp = boolWert"},{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/task-solutions/german/wpb-task-04-solution.html","title":"04 Programming with functions","content":"(**\n---\ntitle: 04 Programming with functions\ncategory: Musterl\u00F6sungen(deutsch)\ncategoryindex: 1\nindex: 4\n---\n*)\n\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/BIO-BTE-12-V-4/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n\n# Task04 - Programming with functions\n\n## Funktionen h\u00F6herer Ordnung\n\n### Task 1.1:\n\nSchreibe folgende Funktion mit Hilfe des Pipe-Operators \u0060|\u003E\u0060 und den angegebenen Funktionen.\n\nTipp: \n\n  - Der Pipeoperator setzt den Parameter links vom Operator ans Ende der rechten Seite: \n\n  - \u0060a |\u003E add b\u0060 ist gleichbedeutend mit \u0060add b a\u0060\n\n*)\nlet mathNotation x y = ((2. \u002B 3. * (x \u002B 1.))**2.) * y\n\n\nlet add (a:float) b = a \u002B b\nlet square (x :float) = x * x\nlet multiply (a:float) b = a * b\n\n\nlet pipeNotation x y =\n    x\n    |\u003E add 1.\n    |\u003E multiply 3.\n    |\u003E add 2.\n    |\u003E square\n    |\u003E multiply y\n\n// Test ob beide notationen das gleiche Ergebnis erzeugen\npipeNotation 1. 7. = mathNotation 1. 7.\n\n(**\n### Task 1.2\n\nDeklariere eine beliebige Funktion mit der Signatur \u0060int -\u003E int -\u003E int\u0060. Achte darauf, dass alle Parameter im Funktionsk\u00F6rper verwendet werden.\n\nIst dies eine Funktion erster Ordnung oder eine Funktion h\u00F6herer Ordnung?\n\n\n*)\n\nlet subtract a b = a - b\n//  Funktion 1. Ordnung \n\n(**\n### Task 1.3\n\nDeklariere eine beliebige Funktion mit der Signatur \u0060int -\u003E int -\u003E (int -\u003E int -\u003E int) -\u003E float\u0060. Achte darauf, dass alle Parameter verwendet werden.\n\nIst dies eine Funktion erster Ordnung oder eine Funktion h\u00F6herer Ordnung?\n*)\n\nlet testFunction a b (f:int -\u003E int -\u003E int) =\n    f a b\n    |\u003E float\n\n// Funktion h\u00F6herer Ordnung\n\n\n(** \n### Task 1.4\n\nRufe die in \u00601.3\u0060 erstellte Funktion auf. Nutze als Parameter zwei beliebige Werte sowie die Funktion aus \u00601.2\u0060.\n\n*)\n\ntestFunction 2 4 subtract\n\n(**\n## Programmieren mit Funktionen\n\n### Task 2.1.1\n\nUnten siehst du einen record type mit dem Namen \u0060Cat\u0060. \nErstelle zwei beliebige Werte des Typs \u0060Cat\u0060 und binde sie an beliebige Namen.\nSchaut euch \u0060\u00DCbung 02\u0060 an, falls es hier Schwierigkeiten geben sollte.\n\n\n*)\ntype Cat = {\n    Name    : string\n    Weight  : float\n    Color   : string\n    Age     : int}\n\nlet createCat n w c a = {Name=n;Weight=w;Color=c;Age=a}\n\nlet paul = createCat \u0022Paulchen\u0022 4.2 \u0022black\u0022 6\nlet lisa = createCat \u0022Lischen\u0022 3.3 \u0022red\u0022 2\n\n(**\n### Task 2.1.2\n\nDeklariere eine Funktion mit dem Namen \u0060getWeight\u0060, die als Parameter eine \u0060Cat\u0060 erh\u00E4lt und deren Gewicht zur\u00FCck gibt. \n\n*)\n\nlet getWeight cat = cat.Weight\n\n(**\n### Task 2.1.3\n\nDu kannst keine mathematischen Standard-Operatoren auf record typen anwenden. \nDeklariere eine Funktion mit dem Namen \u0060applyToWeight\u0060, die zwei Parameter vom Typ \u0060Cat\u0060 (c1 und c2) und einen Parameter vom Typ \u0060(float -\u003E float -\u003E float)\u0060 (f) erh\u00E4lt. \nIm Funktionsk\u00F6rper soll die Funktion f auf die Gewichte der beiden Katzen c1 und c2 angewendet werden.\n\nTipp: Definiere die Typen der Parameter. \n\n\n*)\n\nlet applyToWeight (c1:Cat) c2 (f:float -\u003E float -\u003E float) =\n    f c1.Weight c2.Weight\n\n(**\n### Task 2.1.4\n\nWende die Funktion \u0060applyToWeight\u0060 mit den zuvor erstellten \u0060Cats\u0060 und der Funktion \u0060averageOfTwo\u0060 an.  \n\n\n*)\nlet averageOfTwo (a:float) b =\n    (a \u002B b) / 2.\n\napplyToWeight paul lisa averageOfTwo\n\n(**\n### Task 2.2 (optional)\n\nDiese Aufgabe muss nicht gel\u00F6st werden! Sie dient dazu eine \u0060Cat list\u0060 zu erstellen, die an sp\u00E4terer Stelle ben\u00F6tigt wird.\nWenn du willst, kannst du kommentieren was in den angegebenen Zeilen geschieht (Extrapunkt)\n\n\n*)\n// Dies ist ein Zufallsgenerator. \n// Mit randomNumberGenerator.NextDouble() kann nun ein zuf\u00E4lliger float zwischen 0. und 1. erstellt werden.\n// Mit randomNumberGenerator.Next(x) kann nun ein zuf\u00E4lliger int zwischen 0 und x-1 erstellt werden.\nlet randomNumberGenerator = System.Random()\n\n// Nachfolgend ist eine Funktion dargestellt, die einen Wert vom Typ Cat erstellt.\nlet createRandomCat (i :int) = \n    // Kommentar: An \u0027name\u0027 wird ein string gebunden, der aus dem Zusammenschluss aus \u0022Cat \u0022 und dem Parameter i (integer) besteht, der zu einem string umgewandelt wird.\n    let name   = \u0022Cat \u0022 \u002B string i \n    // Kommentar: An \u0027age\u0027 wird ein integer gebunden, der eine zufaellige Zahl zwischen 0 und 15 ist.\n    let age    = randomNumberGenerator.Next(16)\n    // Kommentar: An \u0027weight\u0027 wird ein float gebunden, der aus einer Berechnung (3\u002B5x) mit einem zufaelligen Wert zwischen 0. und 1. ensteht.\n    let weight = 3. \u002B 5. * randomNumberGenerator.NextDouble()\n    let color  = \n        let colors = [\u0022white\u0022;\u0022red\u0022;\u0022black\u0022;\u0022grey\u0022;\u0022mixed\u0022]\n        // Kommentar: Das \u0027colors\u0027 Array ist 5 Elemente lang. Der Index der zu waehlenden Farbe wird durch modulo 5 bestimmt.\n        // Wenn i \u003E 4, dann liegt der Teilungs-Rest zwischen 0 und 4. Damit ist fuer jeden integer eine Farbe definiert.\n        colors.[i%5]\n    // Kommentar: Hier wird ein Wert des Typs Cat mithilfe der zuvor erstellten Wertebindung erstellt (instantiiert).\n    {\n    Name    = name\n    Weight  = weight\n    Color   = color   \n    Age     = age\n    }\n\n// Kommentar: Hier wird eine Cat-Liste erstellt, die 60 random cats enthaelt\nlet catList = [for i=1 to 60 do yield createRandomCat i]\n(**\n### Task 2.3\n\nErstelle eine float List mit den Werten von 0. bis 100. und binde sie an den Namen \u0060nList\u0060.\n\n\n*)\n\nlet nList = [1. .. 100.]\n\n(**\n### Task 2.4\n\nMit map-Funktionen kann man eine Funktion, die auf einzelnen Elementen angewendet werden kann auf alle Elemente einer Liste anwenden.\nParameter der \u0060map\u0060-Funktion:\n\n  1. \u0060doSomethingWithX\u0060:  Funktion, die auf jedes Listenelement angewendet werden soll\n\n  2. \u0060list\u0060:              Liste der Elemente, auf die \u0060doSomeThingWithX\u0060 angewendet werden soll\n\nDie \u0060List.map\u0060 Funktion wird dann folgenderma\u00DFen angewendet:\n\n  - \u0060List.map (fun listElement -\u003E doSomethingWithX listElement) list\u0060\n\nWende auf jedes Element von \u0060nList\u0060 die Funktion \u0060square\u0060 (Task 1.1) an. Binde das Ergebnis an den Namen \u0060nListSquared\u0060.\n\n*)\n\nlet nListSquared = List.map (fun x -\u003E square x) nList\n\n(**\n### Task 2.5\n\nExtrahiere alle Gewichte aus \u0027catList\u0027 und binde sie an den Namen \u0060catWeights\u0060.\n\n\n*)\n\nlet catWeights = catList |\u003E List.map (fun x -\u003E x.Weight)\n\n(**\n### Task 2.6\n\nBerechne die Summe der Werte aus \u0060nList\u0060. \n\nTipp: Durchsuche das \u0060List\u0060-Modul nach einer passenden Funktion.\n\n*)\n\nList.sum nList\n\n(**\n### Task 2.7\n\nFiltere alle Listenelemente, die durch 15 teilbar sind.\n\nTipp1: Nutze \u0060List.filter\u0060 und die angegebene Funktion.\n*)\n\nlet isDivisibleWithoutRemainder denumerator numerator = \n     numerator % denumerator = 0.\n\nList.filter (isDivisibleWithoutRemainder 15.) nList\n\n(**\n### Task 2.8\n\nBerechne die Summe der Quadrate der einzelnen Werte aus nList.\nVersuche dieses in einem Schritt mit \u0060List.fold\u0060 zu erreichen.\n*)\n\nList.fold (fun acc x -\u003E acc \u002B square x) 0. nList\n\n(**\n### Task 2.9\n\nBerechne das Durchschnittsgewicht der Katzen aus \u0060catList\u0060. \n\nTipp: Die Aufgabe kann entweder durch die Nutzung von Funktionen aus dem \u0060List\u0060-Modul gel\u00F6st werden, oder man l\u00F6st sie durch eine einzige fold Funktion (f\u00FCr Experten).\n*)\n\nList.average catWeights\n\nList.fold (fun acc x -\u003E acc \u002B (x / float catWeights.Length)) 0. catWeights"},{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/task-solutions/german/wpb-task-01-solution.html","title":"01 Hello F#","content":"(**\n---\ntitle: 01 Hello F#\ncategory: Musterl\uFFFDsungen(deutsch)\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/BIO-BTE-12-V-4/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n\n# Task01 - Hello F#\n-------------------------------\nErst einmal die absoluten Basics:\n- **In einem .fsx script:** \n    Markiert die \u002710\u0027, und drueckt Alt\u002BEnter, dann sollte sich die interaktive Konsole oeffnen und euer \n    Output sollte \u0027val it: int = 10\u0027 sein.\n    (Bei einzeiligem Code koennt ihr auch einfach die Zeile auswaehlen und Alt\u002BEnter druecken ohne das alles markiert ist.)\n- **In einem Notebook:**\n    Links von dem Feld unten das die \u002710\u0027 beinhaltet befindet sich ein \u0027play\u0027 Knopf. \n    Dieser Knopf f\uFFFDhrt beim dr\uFFFDcken den jeweiligen Code-block aus und gibt das Ergebnis (hier: 10) darunter aus.\n    **Codebl\uFFFDcke in notebooks m\uFFFDssen immer mit dem Wert enden, der ausgegben werden soll.**\n*)\n\n10\n\n(**\nAuf diese Weise koennt ihr Code den ihr geschrieben habt, direkt testen und euch den Output ansehen.\nVersucht das mal mit der folgenden Zeile und ihr werdet sehen, dass das Ergebnis direkt ausgerechnet wird und 30 ist.\n*)\n\n10 \u002B 20\n\n(**\nAlles was ihr hinter \u0060//\u0060 oder innerhalb von \u0060(* ... *)\u0060 schreibt ist ein Kommentar und wird nicht als Code ausgefuehrt.\nIhr koennt auch Teile einer Zeile mit \u0060(* ... *)\u0060 auskommentieren. \nDie Standardtastenkombination zum auskommentieren ist (Strg \u002B K -\u003E Strg \u002B C)\n*)\n\n10 (*\u002B 40 *) \u002B 30\n\n(**\nSolltet ihr bei einer Uebung nicht auf die Loesung kommen, lasst auf jeden Fall euren Loesungsansatz stehen!\n## Das \u0027let\u0027-Binding\n## Task 1\n### Task 1.1\nBinde den Wert 10 an den Namen \u0027x\u0027. Binde den Wert 20 an den Namen \u0027kaesebrot\u0027.\n*)\n\nlet x = 10\n\nlet kaesebrot = 20\n\n(**\n### Task 1.2\nBinde das Ergebnis der Addition von \u0027x\u0027 mit dem Wert 10 an \u0027y\u0027.\n*)\n\nlet y = x \u002B 10\n\n(**\n### Task 1.3\nBinde einen Vornamen als string an \u0027vorname\u0027.\n*)\n\nlet vorname = \u0022Vorname\u0022\n\n(**\n### Task 1.4\nBerechne den Rest aus 432858049/41 und binde das Ergebnis an \u0027modulo\u0027\n*)\n\nlet modulo = 432858049%41\n\n(**\n### Task 1.5\nBinde die Summe der jeweiligen Summen aus x \u002B 10 und y \u002B 20 an den Namen \u0027summeXY\u0027. \nDie Zwischenergebnisse sollten nicht im globalen Sichtbarkeitsbereich (Scope) liegen.\n*)\n\nlet summeXY =\n    let summeX = x \u002B 10\n    let summeY = y \u002B 20\n    summeX \u002B summeY\n\n// oder k\uFFFDrzer und ohne zwischenErgebnis:\nlet summeXY\u0027 = x \u002B 10 \u002B y \u002B 20\n\n(**\n## Die \u0022printfn\u0022 - Funktion\n### Task 2\n_Tipp: https://docs.microsoft.com/de-de/dotnet/fsharp/language-reference/plaintext-formatting_\n### Task 2.1:  \nBenutze die printfn - Funktion um \u0022Hallo F#\u0022 in die Konsole auszugeben.\n*)\n\nprintfn \u0022Hallo F#\u0022\n\n(**\n### Task 2.2:  \nBenutze die printfn - Funktion um den Wert von \u0027vorname\u0027 in die Konsole auszugeben.\n*)\n\nprintfn \u0022%s\u0022 vorname\n\n(**\n### Task 2.3:  \nBenutzt printfn um \u0027y\u0027 in die Konsole auszugeben.\n*)\n\nprintfn \u0022%i\u0022 y\n\n(**\n## Primitive Datentypen und Funktionen\n### Task 3\n### Task 3.1\nBinde einen beliebigen Wert vom Typ Integer an den Namen intI.\n*)\n\nlet intI = 1\n\n(**\n### Task 3.2\nBinde einen beliebigen Wert vom Typ Float an den Namen floatI.\n*)\n\nlet floatI = 2.\n\n(**\n### Task 3.3\nWandelt entweder intI oder floatI in den Datentyp des anderen um und addiert beide.\n*)\n\nintI \u002B int floatI\n\n// oder:\nfloat intI \u002B floatI\n\n(**\n### Task 3.4\nBerechne den Quotienten aus \u002727\u0027 und \u002713\u0027. Dann berechne den Quotienten von beiden Integern als Float.\n*)\n\n27 / 13\n\nfloat 27 / float 13\n\n(**\n### Task 3.5:\nKonkateniere einen beliebigen Wert vom Typ String mit einem einzelnem Buchstaben (Typ Char)\n*)\n\n\u0022myStrin\u0022 \u002B string \u0027g\u0027\n\n(**\n### Task 3.6:\nDeklariere eine Funktion \u0027mulitplyBy2\u0027 die einen float verdoppelt. \n*)\n\nlet multiplyBy2 (x:float) = 2.0 * x\n\n(**\n### Task 3.7:  \nDeklariere eine Funktion \u0027calculateCylinderVolume\u0027 die aus Radius und Laenge das Volumen eines Zylinders \nzurueckgibt UND zusaetzlich \u0022Das Volumen des Zylinders ist: XX\u0022 in die Konsole printed. Wobei XX natuerlich \ndas korrekte Volumen des Zylinders ist. (Der Output einer printfn Funktion ist Unit.)\nWarum kann es Sinn machen, Ergebnisse zu printen? \n*)\n\n// M\uFFFDgliche Antwort: die print Funktion erlaubt es Zwischenergebnisse zu visualisieren.\nlet calculateCylinderVolume radius laenge =\n    let volumen = System.Math.PI * radius * radius * laenge\n    printfn \u0022Das Volumen des Zylinders ist: %f\u0022 volumen\n    // Der R\uFFFDckgabewert ist gleich dem Wert der an Volumen gebunden wurde\n    volumen\n\n(**\n### Task 3.8:  \nDeklariere eine Funktion die einen Parameter vom Typ Integer als Input nimmt und die \u0027multiplyBy2\u0027 \nFuntkion darauf anwendet\n*)\n\nlet multiplyBy2Two x = multiplyBy2 (float x)\n\n(**\n### Task 3.9:  \nDeklariere eine Funktion die als Input zwei Parameter vom Typ Float, einen Vergleichsoperator z.B. \n(\u003C, \u003E, = ), und einen Parameter vom Typ Boolean akzeptiert. Das Ergebnis aus der Anwendung des angegebenen \nOperators auf die numerischen Parameter soll mit dem Parameter vom Typ Boolean auf Gleichheit ueberprueft werden.\n(_2 Punkte_)\n*)\n\nlet compare (x:float) (y:float) (op: float  -\u003E float -\u003E bool) (boolWert:bool) = \n    let tmp = op x y \n    tmp = boolWert"},{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/task-solutions/german/wpb-task-02-solution.html","title":"02 Functions and Data types","content":"(**\n---\ntitle: 02 Functions and Data types\ncategory: Musterl\u00F6sungen(deutsch)\ncategoryindex: 1\nindex: 2\n---\n*)\n\n(**\n\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/BIO-BTE-12-V-4/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# Task02 - Functions and Data types\n\n## Tuples\n\n### Task 1.1:\n\nDeklariere einen Tuple aus 2. und \u0022Februar\u0022 und binde den Tuple an den Namen \u0060tuple1\u0060.\n*)\n\nlet tuple1 = 2.,\u0022Februar\u0022\n\n(**\n### Task 1.2:\n\nDeklariere einen Tuple aus 2., \u0022Februar\u0022 und \u0022Fruehling\u0022 und bindet ihn an den Namen \u0060tuple2\u0060.\n*)\n\nlet tuple2 = 2.,\u0022Februar\u0022,\u0022Fruehling\u0022\n\n(**\n### Task 1.3:\n\nGreife auf den zweiten Wert des Tuples aus 1.1 zu.\n*)\n\nsnd tuple1\n\n// oder\n\ntuple1 |\u003E fun (x,y) -\u003E y\n\n(**\n### Task 1.4:\n\nBindet \u0060tuple1\u0060 aus Task 1.1 an: \u0060(output1,output2)\u0060\nWarum kann das sinnvoll sein?\nStichwort: Tuple Deconstruction.\n*)\n\nlet output1,output2 = tuple1\n\noutput2\n\n// Sinnvoll, weil man damit aus einem Tupel direkt das Element an einen Namen bindet statt an sp\u00E4terer Stelle immer wieder umst\u00E4ndlich auf der jeweilige Element zugreifen zu m\u00FCssen.\n\n(**\n## Record Types\n\n### Task 2.1: \n\nDefiniere einen Record Type mit dem Namen \u0060Person\u0060. Person soll die Felder \u0060Name\u0060(string) und \u0060Alter\u0060(int) haben.\nBei Record Types wird kein camel case, sondern pascal case verwendet (wie camel case nur ist der erste Buchstabe auch gro\u00DF).\n*)\n\ntype Person = {\n    Name    : string\n    Alter   : int\n}\n\n(**\n### Task 2.2:\n\nErstellt einen Wert des Typs \u0060Person\u0060 mit ausgedachten Feldwerten und bindet ihn an den Namen \u0060meinePerson1\u0060.\nGreift auf das Feld \u0060Alter\u0060 von \u0060meinePerson1\u0060 zu.\n*)\n\nlet meinePerson1 = {\n    Name    = \u0022Max Mustermann\u0022\n    Alter   = 37\n}\n\nmeinePerson1.Alter\n\n(**\n### Task 2.3:\n\nDeklariere eine Funktion die zwei Inputparameter erhaelt und als Rueckgabewert eine \u0060Person\u0060 gibt.\nBinde ein Ergebnis dieser Funktion an den Namen \u0060meinePerson2\u0060.\n*)\n\nlet erzeugePerson name alter = {\n    Name    = name\n    Alter   = alter\n}\n\nlet meinePerson2 = erzeugePerson \u0022Eva Mustermann\u0022 13\n\n(**\n### Task 2.4:\n\nDefiniere einen weiteren Record Type mit dem Namen \u0060ErweitertePerson\u0060. ErweitertePerson soll die gleichen Felder wie \u0060Person\u0060\nhaben, bekommt aber noch das zusaetzliche Feld \u0060Hobby\u0060. Da man alles zu seinem Hobby machen kann, soll\n\u0027Hobby\u0027 vom Typ generic type sein.\nTipp: Zwischen dem Namen des Record types und \u0060=\u0060 muss der generic type durch \u0060\u003C\u0027a\u003E\u0060 angegeben werden\n*)\n\ntype ErweitertePerson\u003C\u0027a\u003E = {\n    Name    : string\n    Alter   : int\n    Hobby   : \u0027a\n}\n\n(**\n### Task 2.5\n\nErstellt einen Wert des Typs \u0060ErweitertePerson\u0060.\n*)\n\nlet meinePerson3 = {\n    Name    = \u0022Otto Normalb\u00FCrger\u0022\n    Alter   = 50\n    Hobby   = \u0022Fu\u00DFball gucken\u0022\n}\n\n(**\n## Signatures\n\n### Task 3.1\n\nDeklariere eine beliebige Funktion mit der Signatur \u0060int -\u003E int\u0060.\n*)\n\nlet beliebigeFunktion x = x \u002B 1\n\n(**\n### Task 3.2\n\nDeklariere eine beliebige Funktion mit der Signatur \u0060int -\u003E (int -\u003E int) -\u003E float\u0060.\n*)\n\nlet beliebigeFunktion2 x (andereFunktion : int -\u003E int) = andereFunktion x |\u003E float\n\n(**\n### Task 3.3\n\nBeschreibe den Rueckgabewert einer Funktion mit folgender Signatur \u0060char -\u003E (string -\u003E char -\u003E float)\u0060.\n*)\n\n// Der R\u00FCckgabewert ist eine Funktion, die einen Parameter vom Typ \u0027string\u0027 und einen vom Typ \u0027char\u0027 nimmt und einen float zur\u00FCckgibt.\n\n(**\n## Collection types\n\n### Task 4.1\n\nErstelle eine int Liste mit den Zahlen 1 bis 100 und binde sie an einen Namen.\n*)\n\nlet meineListe = [1 .. 100]\n\n// oder\n\nlet meineListe\u0027 = List.init 100 (fun i -\u003E i \u002B 1)\n\n(**\n### Task 4.2\n\nBinde das erste und das letzte Element der Liste an je einen Namen.\n*)\n\nlet erstesElement = meineListe.[0]\nlet letztesElement = meineListe.[99] // erfordert, zu wissen, wie viele Elemente die Liste hat\n\n// oder\n\nlet erstesElement\u0027 = List.item 0 meineListe\nlet letztesElement\u0027 = List.item 99 meineListe // erfordert, zu wissen, wie viele Elemente die Liste hat\n\n// oder \n\nlet erstesElement\u0027\u0027 = List.head meineListe\nlet letztesElement\u0027\u0027 = List.last meineListe\n\n(**\n### Task 4.3\n\nErstelle ein float Array mit den Zahlen von 1. bis 100. und binde es an einen Namen.\n*)\n\nlet meinArray = [|1. .. 100.|]\n\n// oder\n\nlet meinArray\u0027 = Array.init 100 (fun i -\u003E i \u002B 1 |\u003E float)\n\n(**\n### Task 4.4\n\nBinde das 15. Element des Arrays aus 4.3 an einen Namen.\n*)\n\nlet fuenfzehntesElement = meinArray.[14]\n\n// oder\n\nlet fuenfzehntesElement\u0027 = Array.item 14 meinArray\n\n// oder\n\nlet fuenfzehntesElement\u0027\u0027 = Array.get meinArray 14\n\n(**\n### Task 4.5\n\nErstelle eine Map, die alle Monate enthaelt. Verwende dafuer die Zahl des Monats (integer) als Key und den Namen (string) als Value.\n*)\n\nlet alleMonate = Map [\n    1, \u0022Januar\u0022\n    2, \u0022Februar\u0022\n    3, \u0022Maerz\u0022\n    4, \u0022April\u0022\n    5, \u0022Mai\u0022\n    6, \u0022Juni\u0022\n    7, \u0022Juli\u0022\n    8, \u0022August\u0022\n    9, \u0022September\u0022\n    10, \u0022Oktober\u0022\n    11, \u0022November\u0022\n    12, \u0022Dezember\u0022\n]\n\n(**\n### Task 4.6\n\nUeberpruefe anhand eines geeigneten Keys, ob der Monat Maerz in der Map vorhanden ist.\n*)\n\nalleMonate.[3] = \u0022Maerz\u0022\n\n// oder\n\nMap.containsKey 3 alleMonate // ob es sich beim Value an der Stelle des Keys 3 jedoch um Maerz oder etwas anderes handelt, wird nicht beantwortet\n\n// oder\n\nMap.exists (fun key value -\u003E key = 3 \u0026\u0026 value = \u0022Maerz\u0022) alleMonate\n\n(**\n### Task 4.7\n\nErstelle zwei Sets. Eins mit Zahlen von 1 bis 10 und eins mit Zahlen von 3 bis 7 und binde sie an je einen Namen.\n*)\n\nlet set1bis10 = Set [1 .. 10]\n\nlet set3bis7 = Set [3 .. 7]\n\n(**\n### Task 4.8 \n\nVergleicht die zuvor erstellten Sets. Bildet die Schnittmenge (intersect) und die Vereinigungsmenge (union) aus beiden Sets und bindet sie an je einen Namen.\nTipp: Nutzt das Set Modul um durch \u0027reindotten\u0027 geeignete Funktionen zu erhalten.\n*)\n\nlet meineSchnittmenge = Set.intersect set1bis10 set3bis7\n\nlet meineVereinigungsmenge = Set.union set1bis10 set3bis7"},{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/task-solutions/german/wpb-task-05-solution.html","title":"05 Programming with Objects","content":"(**\n---\ntitle: 05 Programming with Objects \ncategory: Musterl\u00F6sungen(deutsch)\ncategoryindex: 1\nindex: 5\n---\n*)\n\n(**\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/BIO-BTE-12-V-4/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# Task05 - Programming with Objects \n\n## Ver\u00E4nderliche Werte\n\n### Task 1.1:\n\nErstellen und Ver\u00E4ndern von ver\u00E4nderlichen Werten\n\nTipp: \n\n- Benutzt das \u0060mutable\u0060 keyword\n- Zur Ver\u00E4nderung der Werte wird der \u0060\u003C-\u0060 Operator verwendet\n\n### Subtask 1.1.1\n\nErstelle einen ver\u00E4nderlichen Integer mit dem Wert 1 und bindet ihn an den Namen x\n\n\n*)\n\nlet mutable x = 1\n\n(**\n### Subtask 1.1.2\n\nVer\u00E4ndere den Wert der an x gebunden ist indem ihr den Wert den x tr\u00E4gt mit 5 multipliziert \n\n*)\n\nx \u003C- (x * 5)\n\n(**\n### Subtask 1.1.3\n\nErstelle einen Record Type \u0060Mensch\u0060 mit \n\n- dem unver\u00E4nderlichen Feld \u0060Name\u0060 vom Typ string\n- und dem ver\u00E4nderlichen Feld \u0060Alter\u0060 vom Typ int\n\n*)\n\ntype Mensch =\n    {\n        Name : string\n        mutable Alter : int\n    }\n\n(**\n### Subtask 1.1.4\n\nErstelle die Funktion \u0060geburtstagFeiern\u0060 die als Parameter einen Wert des Typen \u0060Mensch\u0060 erh\u00E4lt und das Alter des Menschen um eins erh\u00F6ht\n\n*)\n\nlet geburtstagFeiern (m : Mensch) =\n    m.Alter \u003C- m.Alter \u002B 1\n\n(**\n### Subtask 1.1.5\n\nErstelle einen Menschen, binde ihn an einen Namen und lass diesen erstellten Menschen mit der Funktion \u0060geburtstagFeiern\u0060 altern.\n\n*)\n\nlet mensch1 = { Name = \u0022Max\u0022; Alter = 22 }\n\ngeburtstagFeiern mensch1\n\n(**\n### Task 1.2 (Bonusaufgabe) Ver\u00E4nderliche Werte in Funktionen\n\nErstelle eine eigene Version der \u0060Array.max\u0060 Funktion. Diese Funktion soll ein Array von ints erhalten und den gr\u00F6\u00DFten der ints zur\u00FCckgeben.\nSignatur: \u0060int [] -\u003E int\u0060\n\nDabei soll der aktuell gr\u00F6\u00DFte int ein \u0060ver\u00E4nderlicher Wert\u0060 sein und es soll eine \u0060for-Schleife\u0060 verwendet werden.\n\n*)\n\nlet arrayMax (array : int[]) = \n    let mutable maxValue = array.[0] \n    for i in array do\n        if i \u003E maxValue then\n            maxValue \u003C- i\n    maxValue\n\nlet arrayMax2 (array : int[]) = \n    let mutable maxValue = array.[0] \n    for i = 1 to array.Length - 1 do\n        if array.[i] \u003E maxValue then\n            maxValue \u003C- array.[i]\n    maxValue\n\nlet array1 = [|4; 23; 6; 4; 7|]\n\narrayMax array1\narrayMax2 array1\n\n(**\n## Vererbung\n\n### Task 2.1 Erstellen von Klassen und Objekten\n\n### Subtask 2.1.1\n\nIm folgenden wird die Klasse \u0060Fahrzeug\u0060 erstellt. Versuche nachzuvollziehen, was passiert und kommentiere jede Zeile kurz\n\nKeywortfundgrube: Methode, Feld, Konstruktor, Parameter, alternativ, binden\n\n\n*)\n\n// Kommentar: Es wird eine Klasse namens \u0060Fahrzeug\u0060 erstellt, deren Hauptkonstruktor einen Parameter namens \u0060hersteller\u0060 vom Typ string erh\u00E4lt\ntype Fahrzeug (hersteller:string) =\n    // Kommentar: Ein Feld namens \u0060Hersteller\u0060 wird definiert, an das der Wert des parameters \u0060hersteller\u0060 gebunden wird\n    member self.Hersteller = hersteller\n    // Kommentar: Es wird eine parameterlose Methode namens \u0060Fahren\u0060 definiert, welche \u00FCber die Selbstreferenz das Feld \u0060Hersteller\u0060 verwendet\n    member self.Fahren() = printfn \u0022%s macht brumm brumm\u0022 self.Hersteller\n    // Kommentar: Ein parameterloser alternativer Konstruktor wird erstellt.\n    new() = Fahrzeug(\u0022VW\u0022)\n\n(**\n### Subtask 2.1.2\n\nInstanziiere 2 Objekte des Typs \u0060Fahrzeug\u0060. Verwende einmal den den Haupt- und einmal den alternativen Konstruktor\n\n*)\n\nlet car1 = new Fahrzeug(\u0022Ford\u0022)\n\nlet car2 = new Fahrzeug()\n\n(**\n### Task 2.2 Vererbung\n\n### Subtask 2.2.1\n\nHier ist ein Beispiel f\u00FCr die Vererbung eines Typen, namentlich der Typ \u0060Motorrad\u0060 der vom Typ \u0060Fahrzeug\u0060 erbt. \n\nErstelle analog einen Typen \u0060Auto\u0060, der auch vom Typ \u0060Fahrzeug\u0060 erben soll. Dieser Typ soll aber zus\u00E4tzlich das Feld \u0060AnzahlTueren\u0060 enthalten. \nW\u00E4hle hierzu einen passenden primitiven Typen und passe auch den Konstruktor an, sodass diese Anzahl der T\u00FCren auch beim Instanziieren gesetzt werden kann.\n\n*)\n\ntype Motorrad (hersteller:string) =\n\n    inherit Fahrzeug(hersteller)\n\n    new() = Motorrad(\u0022Kawasaki\u0022)\n\ntype Auto (hersteller : string, anzahlTueren : int) =\n\n    inherit Fahrzeug(hersteller)\n\n    member self.AnzahlTueren = anzahlTueren\n\n    new() = Auto(\u0022Mercedes\u0022,4)\n\n(**\n### Subtask 2.2.2\n\nErstelle eine Funktion, welche einen Parameter des Typs \u0060Fahrzeug\u0060 enth\u00E4lt und die Methode \u0060Fahren\u0060 dieses Fahrzeuges ausf\u00FChrt.\n\n*)\n\nlet fahren (fahrzeug : #Fahrzeug) =\n\n    fahrzeug.Fahren()\n\n(**\n### Subtask 2.2.3\n\nErstelle ein \u0060Auto\u0060 und binde en an einen Namen. Dann wende die oben definierte Funktion zum \u0060Fahren\u0060 darauf an.\n\n*)\n\nlet car3 = new Auto(\u0022Toyota\u0022, 3)\n\nfahren car3\n\n(**\n\n### Task 2.3 (Bonusaufgabe) Ver\u00E4nderliche Werte in Objekten\n\nDeklariere eine Klasse \u0060Cabrio\u0060 die vom Typ \u0060Fahrzeug\u0060 erbt. \n\nDiese Klasse soll ein Feld \u0060DachOffen\u0060 vom Typ \u0060bool\u0060 haben und zus\u00E4tzlich Methoden, mit denen man das Dach \u00F6ffnen und schlie\u00DFen kann\n\n*)\n\n// L\u00F6sung \u00FCber Feld nur mit get (default), und Methoden die das Verhalten regeln (bevorzugt)\ntype Cabrio (hersteller:string, tueren:int) =\n\n    inherit Auto(hersteller,tueren)\n\n    let mutable dachOffen = false\n\n    // Feld abrufbar aber nicht verw\u00E4nderbar\n    member this.DachOffen = dachOffen\n\n    // Methoden, zur gezielten Zustands\u00E4nderung\n    member self.Oeffnen() = \n        if dachOffen then printfn \u0022Das Dach ist bereits offen!\u0022\n        else printfn \u0022Das Dach ist jetzt offen.\u0022\n        dachOffen \u003C- true\n\n    member self.Schliessen() = \n        if dachOffen then printfn \u0022Das Dach ist jetzt zu!\u0022\n        else printfn \u0022Das Dach ist schon zu!\u0022\n        dachOffen \u003C- false        \n\n    // Methoden, zum automatischen Zustandswechsel\n    member this.DachBetaetigen() =\n        if dachOffen = true then \n            dachOffen \u003C- false\n        else\n            dachOffen \u003C- true\n\n// Zus\u00E4tzliche Hilfsfunktionen\nlet dachSchliessen (c:Cabrio) = \n    c.Schliessen()\n\nlet dachOeffnen (c:Cabrio) = \n    c.Oeffnen()\n\n\nlet neuesCabrio = new Cabrio(\u0022Audi\u0022,4)\n\ndachOeffnen neuesCabrio\n\n\n\n// L\u00F6sung \u00FCber Feld mit get/set, ohne Methoden\ntype Cabrio2 (hersteller:string, tueren:int) =\n\n    inherit Auto(hersteller,tueren)\n\n    let mutable dachOffen = false\n\n    // Feld abrufbar und verw\u00E4nderbar\n    member this.DachOffen\n        with get () = dachOffen\n        and set (v) = dachOffen \u003C- v\n\n// In diesem Fall m\u00FCssten die Funktionen die Logik selbst tragen\nlet dachOeffnen2 (c:Cabrio2) = \n    if c.DachOffen then printfn \u0022Das Dach ist bereits offen!\u0022\n    else printfn \u0022Das Dach ist jetzt offen.\u0022\n    c.DachOffen \u003C- true\n\nlet dachSchliessen2 (c:Cabrio2) = \n    if c.DachOffen then printfn \u0022Das Dach ist jetzt zu!\u0022\n    else printfn \u0022Das Dach ist schon zu!\u0022\n    c.DachOffen \u003C- false       \n\nlet neuesCabrio2 = new Cabrio2(\u0022Audi\u0022,4)\n\ndachOeffnen2 neuesCabrio2 \n\n\n(**\n## Polymorphismus\n\n### Task 3.1\n\nWir wollen hier Personen implementieren, die ihren Namen sagen k\u00F6nnen. In Japan wird auch im allt\u00E4glichen Leben normalerweise der Familienname vor dem Eigennamen genannt. \nSo ist Yoko Ono in Japan als Ono Yoko bekannt. Um diesen Unterschied programmatisch darzustellen, wurde der Code folgendermassen geschrieben:\n\nOrdne die folgenden Begriffen den zugeh\u00F6rigen Codebausteinen zu: \u0060Klassendeklaration\u0060, \u0060Objektinstanziierung\u0060, \u0060Interfacedeklaration\u0060\n\n\n*)\n// Bezeichnung: Interfacedeklaration\ntype IPerson =\n    abstract FamilienName   : string\n    abstract EigenName      : string\n    abstract NamenSagen     : unit -\u003E string\n\n// Bezeichnung: Klassendeklaration\ntype Japaner (fn, en) =\n    let familienName = fn\n    let eigenName = en\n    interface IPerson with\n        member self.FamilienName = familienName\n        member self.EigenName = eigenName\n        member self.NamenSagen () = familienName \u002B \u0022 \u0022 \u002B eigenName\n\n// Bezeichnung: Klassendeklaration\ntype Deutscher (fn, en) =\n    let familienName = fn\n    let eigenName = en\n    interface IPerson with\n        member self.FamilienName = familienName\n        member self.EigenName = eigenName\n        member self.NamenSagen () = eigenName \u002B \u0022 \u0022 \u002B familienName\n\n// Bezeichnung: Objektinstanziierung\nlet yokoOno = Japaner(\u0022Ono\u0022,\u0022Yoko\u0022)\n\n// Bezeichnung: Objektinstanziierung\nlet angeloMerte = Deutscher(\u0022Merte\u0022,\u0022Angelo\u0022)\n(**\n### Task 3.2\n\nGreife auf die Methode \u0060NamenSagen\u0060 der beiden Personen zu. \nTipp: Verwende den korrekten \u0060casting Operator\u0060\n\n*)\n// Variante1\nlet say = yokoOno :\u003E IPerson\nsay.NamenSagen()\n\n// Variante2\n(angeloMerte :\u003E IPerson).NamenSagen()\n\n// Variante3\nlet namenSagen (p : #IPerson) =\n    p.NamenSagen()\n\nnamenSagen yokoOno\n\n(**\n### Task 3.3\n\nErkl\u00E4re kurz in eigenen Worten, warum in diesem Beispiel Polymorphismus verwendet wurde und nicht Vererbung.\n\n*)\n\n// In diesem Fall sollen alle Personen die gleiche Methode \u0060NamenSagen\u0060 besitzen. Was genau in der Methode passiert soll aber je nach Nationalit\u00E4t unterschiedlich sein.\n// Bei Vererbung w\u00FCrde das Verhalten der Methode einmal definiert werden und alle erbenden Personen w\u00FCrde den Namen auf die gleich Weise sagen.\n// Polymorphismus erlaubt es, dass das konkrete Verhalten sich f\u00FCr die gleich benutzbare Methode zwischen den Leuten unterscheidet.\n\n(**\n### Task 3.4\n\nIm fernen Land Dingeldongel wird wie auch in Deutschland erst der Eigenname und dann der Familienname genannt. Beide werden jedoch revertiert. (Angela Merkel -\u003E alegnA lekreM)\n\nDeklariere die Klasse \u0060Dingeldongler\u0060, die das Interface \u0060IPerson\u0060 implementiert.\n\nTipp: Verwende die gegebene string-revertier Funktion\n\n\n*)\nlet revert (s:string) = System.String(s.ToCharArray() |\u003E Array.rev)\n\ntype Dingeldongler (fn, en) =\n    let familienName = fn\n    let eigenName = en \n    interface IPerson with\n        member self.FamilienName = familienName\n        member self.EigenName = eigenName\n        member self.NamenSagen () = revert eigenName \u002B \u0022 \u0022 \u002B revert familienName\n\nlet amblimKamblim = Dingeldongler(\u0022Kamblim\u0022, \u0022Amblim\u0022)\n(amblimKamblim :\u003E IPerson).NamenSagen()"},{"uri":"/BIO-BTE-12-V-4-SOLUTIONS/task-solutions/german/wpb-task-03-solution.html","title":"03 Control flow","content":"(**\n---\ntitle: 03 Control flow\ncategory: Musterl\u00F6sungen(deutsch)\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(**\n\n[![Binder]({{root}}img/badge-binder.svg)](https://mybinder.org/v2/gh/csbiology/BIO-BTE-12-V-4/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script]({{root}}img/badge-script.svg)]({{root}}{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook]({{root}}img/badge-notebook.svg)]({{root}}{{fsdocs-source-basename}}.ipynb)\n\n# Task03 - Control Flow\n\n\n## If-then-else\n\n### Task 1.1:\n\nDeklariere eine Funktion, die einen Parameter \u0060x\u0060 vom Typ float erhaelt. Ist der Wert von \u0060x\u0060 groesser Null, so soll die Funktion den Wert zurueckgeben, falls nicht soll das \nVorzeichen umgekehrt und denn der Wert zerueckgegeben werden.  \nTipp: Multiplikation\n\n*)\n\nlet myFunc x = \n    if x \u003E 0. then \n        x \n    else \n        x * -1.\n\n(**\n\n### Task 1.2:\n\nDeklariere eine Funktion, die drei Zahlen als Parameter bekommt. Die groesste der drei Zahlen soll als Ergebnis ausgegeben werden.  \nTipp: \u0060elif\u0060!\n\n*)\n\n// mit elif und bool-Operatoren\nlet myFunc2 x y z =\n    if x \u003E y \u0026\u0026 x \u003E z then\n        x\n    elif y \u003E z then\n        y\n    else z\n\n// ohne elif und bool-Operatoren\nlet myFunc2\u0027 x y z =\n    if x \u003E y then\n        if x \u003E z then\n            x\n        else\n            z\n    else\n        if y \u003E z then\n            y\n        else z\n\n(**\n\n### Task 1.3:\n\nDeklariere eine Funktion, die eine Jahreszahl als Parameter bekommt. Wenn es sich um ein Schaltjahr handelt, soll das Ergebnis \u0060true\u0060 sein, andernfalls \u0060false\u0060.  \nTipps:  \n- Ist die Jahreszahl durch vier teilbar, aber nicht durch 100, ist es ein Schaltjahr. 2008 faellt unter diese Regel.  \n- Ist die Jahreszahl durch 100 teilbar, aber nicht durch 400, ist es kein Schaltjahr. 2100 wird kein Schaltjahr sein.  \n- Ist die Jahreszahl durch 400 teilbar, dann ist es immer ein Schaltjahr. Deshalb war das Jahr 2000 ein Schaltjahr.\n\n*)\n\nlet istSchaltjahr jahreszahl =\n    if jahreszahl % 4 = 0 \u0026\u0026 jahreszahl % 100 \u003C\u003E 0 then\n        true\n    elif jahreszahl % 100 = 0 \u0026\u0026 jahreszahl % 400 \u003C\u003E 0 then\n        false\n    elif jahreszahl % 400 = 0 then \n        true\n    else false\n\n(**\n\n## Pattern matching\n\n### Task 2.1:\n\nDeklariere eine Funktion mit denselben Eigenschaften wie in Task 1.1 beschrieben. Verzichte auf if-then-else Expressions und verwende Pattern Matching.  \nTipp: Guarding Rules \u002B Wildcard\n\n*)\n\nlet myFunc3 x =\n    match x with\n    | a when a \u003E 0. -\u003E x\n    | _             -\u003E x * -1.\n\n(**\n\n### Task 2.2:\n\nGegeben ist die UnionCase Definition \u0060Monat\u0060:\n\u0060\u0060\u0060fsharp\ntype Monat =\n    | Januar\n    | Februar\n    | Maerz\n    | April\n    | Mai\n    | Juni\n    | Juli\n    | August\n    | September\n    | Oktober\n    | November\n    | Dezember\n\u0060\u0060\u0060\n\nund die UnionCase Definition \u0060Jahreszeit\u0060:\n\u0060\u0060\u0060fsharp\ntype Jahreszeit =\n    | Fruehling\n    | Sommer\n    | Herbst\n    | Winter\n\u0060\u0060\u0060\n\nDeklariere eine Funktion, die einen Parameter \u0060m\u0060 vom Typ \u0060Monat\u0060 besitzt. Verwende Pattern Matching, um jeden\nMonat einer Jahreszeit zuzuordnen.\n\n*)\n\ntype Monat =\n    | Januar\n    | Februar\n    | Maerz\n    | April\n    | Mai\n    | Juni\n    | Juli\n    | August\n    | September\n    | Oktober\n    | November\n    | Dezember\ntype Jahreszeit =\n    | Fruehling\n    | Sommer\n    | Herbst\n    | Winter\n\n\nlet monatZuJahreszeit m =\n    match m with\n    | Dezember  | Januar    | Februar   -\u003E Winter\n    | Maerz     | April     | Mai       -\u003E Fruehling\n    | Juni      | Juli      | August    -\u003E Sommer\n    | _                                 -\u003E Herbst\n\n(**\n\n### Task 2.3:\n\nPattern matching ist sehr gut dazu geeignet Datenstrukturen zu zerlegen (eng. deconstruction). Deklariere eine\nFunktion, die den Record type \u0060Person\u0060 (bekannt aus Uebung 2) erhaelt und \u0060true\u0060 zurueckgibt, falls der Nachname \u0060Mueller\u0060 lautet.  \nTipp: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/records#pattern-matching-with-records\n\n*)\n\ntype Person = {\n    Name    : string\n    Alter   : int\n}\n\nlet istNameMueller person =\n    match person.Name with\n    | \u0022Mueller\u0022 -\u003E true\n    | _         -\u003E false\n\n(**\n\n## Schleifen\n\n### Task 3.1:\n\nDeklariere eine Funktion, die einen Parameter \u0060n\u0060 vom Typ \u0060int\u0060 erhaelt.  \nDie Funktion soll alle ganzen Zahlen von 1 bis n in der Konsole ausgeben (Tipp: \u0060printfn\u0060). Benutze dafuer eine \u0060for\u0060-Loop.\n\n*)\n\nlet myFunc4 n =\n    for i = 1 to n do\n        printfn \u0022%i\u0022 i\n\n(**\n\n### Task 3.2:\n\nDeklariere eine Funktion, die einen Parameter \u0060n\u0060 vom Typ \u0060int\u0060 erhaelt.  \nDie Funktion soll alle ganzen Zahlen von 1 bis n in einer Liste speichern.  \nTipps: Sequence Expressions, Comprehensions  \nExtra Punkt: schreibe nur alle geraden Zahlen in eine Liste, Tipps: if-then-else, modulo.\n\n*)\n\nlet myFunc5 n =\n    [for i = 1 to n do i] // veraltet: [for i = 1 to n do yield i]\n\nlet myFunc5E n =\n    [for i = 1 to n do \n        if i % 2 = 0 then i]\n\n(**\n\n### Task 3.3:\n\nDeklariere eine Funktion, die einen Parameter \u0060n\u0060 vom Typ \u0060int\u0060 und einen Parameter \u0060f\u0060 mit der Signatur \u0060(int -\u003E int)\u0060 erhaelt.  \nDie Funktion soll \u0060f\u0060 auf alle ganzen Zahlen von 1 bis n anwenden und in einer in einer Liste speichern.  \nTipps: Sequence Expressions, Comprehensions\n\n*)\n\nlet myFunc6 n (f : int -\u003E int) =\n    [for i = 1 to n do f i]\n\n(**\n\n## Rekursion\n\n### Task 4.1:\n\nModifiziere folgende Funktion (bekannt aus der Vorlesung) so, dass sie am Ende ausgibt wie viele Stufen bewaeltigt wurden.\n\u0060\u0060\u0060fsharp\nlet rec stufeSteigen nStufen position =\n    if position = nStufen \u002B 1 then\n        printfn \u0022Puh, geschafft\u0022\n    else\n        printfn \u0022Ich sollte mehr Sport machen\u0022\n        stufeSteigen nStufen (position \u002B 1)\n\u0060\u0060\u0060\n\n*)\n\nlet rec stufeSteigen nStufen aktPosition startPosition =\n    if aktPosition = nStufen \u002B 1 then\n        printfn \u0022Puh, geschafft. Das waren immerhin %i Stufen!\u0022 (nStufen - startPosition)\n    else\n        printfn \u0022Ich sollte mehr Sport machen\u0022\n        stufeSteigen nStufen (aktPosition \u002B 1) startPosition\n\nlet stufeSteigen\u0027 nStufen position =\n    let rec loop positionLoop =\n        if positionLoop = nStufen \u002B 1 then\n            printfn \u0022Puh, geschafft. Das waren immerhin %i Stufen!\u0022 (nStufen - position)\n        else\n            printfn \u0022Ich sollte mehr Sport machen\u0022\n            loop (positionLoop \u002B 1)\n    loop position\n\n(**\n\n### Task 4.2:\n\nModifiziere die folgende Funktion (bekannt aus der Vorlesung) so, dass sie -1 zurueckgibt, falls abzusehen ist, dass das Ergebnis groesser als 1000 wird.  \nTipp: Hier hilft die \u0060print\u0060-Funktion um Zwischenergebnisse zu visualisieren und die Funktion besser zu verstehen. Z. B.: \u0060printfn \u0022n:%i, acc\u0027:%i\u0022 n acc\u0060.\n\u0060\u0060\u0060fsharp\nlet rec facultaet acc n  =\n    if n = 1 then\n        acc \n    else\n        let acc\u0027 = n * acc\n        facultaet acc\u0027 (n - 1)\n\nfacultaet 1 4\n\u0060\u0060\u0060\n\n*)\n\nlet rec facultaet acc n  =\n    if n = 1 then\n        acc \n    elif acc * n \u003E 1000 then\n        -1\n    else\n        let acc\u0027 = n * acc\n        facultaet acc\u0027 (n - 1)"}]